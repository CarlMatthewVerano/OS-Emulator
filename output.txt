Folder Structure
--------------------------------------------------
src/
    Command.h
    Config.cpp
    Config.h
    Console.h
    ConsoleManager.cpp
    ConsoleManager.h
    MainConsole.cpp
    MainConsole.h
    MemoryManager.cpp
    MemoryManager.h
    OSEmulator.cpp
    PrintCommand.cpp
    PrintCommand.h
    Process.cpp
    Process.h
    Scheduler.h
    SchedulerFCFS.cpp
    SchedulerFCFS.h
    SchedulerRR.cpp
    SchedulerRR.h
    Screen.cpp
    Screen.h
    ThreadSafeQueue.h


File Contents
--------------------------------------------------


./src\Command.h
File type: .h
#pragma once

#include <string>

class Process;

class Command {
public:
    virtual ~Command() = default;
    virtual void execute(Process* process, int coreId) = 0;
    virtual std::string getDescription() const = 0;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\Config.cpp
File type: .cpp
#include "Config.h"
#include <fstream>
#include <sstream>
#include <iostream>

bool Config::isPowerOfTwo(unsigned int x) {
    return x && !(x & (x - 1));
}

bool Config::isInValidRange(unsigned int x) {
    return x >= 2 && x <= 0xFFFFFFFF;  // [2, 2^32]
}

Config& Config::getInstance() {
    static Config instance;
    return instance;
}

Config::Config()
    : numCpu(4),
    schedulerType("rr"),
    quantumCycles(5),
    batchProcessFreq(1),
    minIns(1000),
    maxIns(2000),
    delaysPerExec(0),
    maxOverallMem(512),
    memPerFrame(256),
    minMemPerProc(512),
    maxMemPerProc(512) {
}

bool Config::loadConfig(const std::string& filename) {
    std::ifstream configFile(filename);
    if (!configFile) {
        std::cerr << "Failed to open " << filename << std::endl;
        return false;
    }

    std::string line;
    while (std::getline(configFile, line)) {
        // Ignore empty lines and comments
        if (line.empty() || line[0] == '#') continue;

        std::istringstream iss(line);
        std::string paramName;
        iss >> paramName;

        if (paramName == "num-cpu") {
            iss >> numCpu;
            if (numCpu < 1 || numCpu > 128) {
                std::cerr << "Invalid num-cpu in " << filename << ": must be between 1 and 128" << std::endl;
                return false;
            }
        }
        else if (paramName == "scheduler") {
            std::string schedulerValue;
            iss >> schedulerValue;
            schedulerType = stripQuotes(schedulerValue);
            if (schedulerType != "fcfs" && schedulerType != "rr") {
                std::cerr << "Invalid scheduler type in " << filename << ": must be 'fcfs' or 'rr'" << std::endl;
                return false;
            }
        }
        else if (paramName == "quantum-cycles") {
            iss >> quantumCycles;
            if (quantumCycles < 1) {
                std::cerr << "Invalid quantum-cycles in " << filename << ": must be greater than 0" << std::endl;
                return false;
            }
        }
        else if (paramName == "batch-process-freq") {
            iss >> batchProcessFreq;
            if (batchProcessFreq < 1) {
                std::cerr << "Invalid batch-process-freq in " << filename << ": must be greater than 0" << std::endl;
                return false;
            }
        }
        else if (paramName == "min-ins") {
            iss >> minIns;
            if (minIns < 1) {
                std::cerr << "Invalid min-ins in " << filename << ": must be greater than 0" << std::endl;
                return false;
            }
        }
        else if (paramName == "max-ins") {
            iss >> maxIns;
            if (maxIns < 1) {
                std::cerr << "Invalid max-ins in " << filename << ": must be greater than 0" << std::endl;
                return false;
            }
        }
        else if (paramName == "delay-per-exec") {
            iss >> delaysPerExec;
            if (delaysPerExec < 0) {
                std::cerr << "Invalid delays-per-exec in " << filename << ": must be non-negative" << std::endl;
                return false;
            }
        }
        else if (paramName == "max-overall-mem") {
            iss >> maxOverallMem;
            if (!isInValidRange(maxOverallMem) || !isPowerOfTwo(maxOverallMem)) {
                std::cerr << "Invalid max-overall-mem in " << filename << ": must be power of 2 in range [2, 2^32]" << std::endl;
                return false;
            }
        }
        else if (paramName == "mem-per-frame") {
            iss >> memPerFrame;
            if (!isInValidRange(memPerFrame) || !isPowerOfTwo(memPerFrame)) {
                std::cerr << "Invalid mem-per-frame in " << filename << ": must be power of 2 in range [2, 2^32]" << std::endl;
                return false;
            }
            if (memPerFrame > maxOverallMem) {
                std::cerr << "Invalid mem-per-frame in " << filename << ": must be less than or equal to max-overall-mem" << std::endl;
                return false;
            }
        }
        else if (paramName == "min-mem-per-proc") {
            iss >> minMemPerProc;
            if (!isInValidRange(minMemPerProc) || !isPowerOfTwo(minMemPerProc)) {
                std::cerr << "Invalid min-mem-per-proc in " << filename << ": must be power of 2 in range [2, 2^32]" << std::endl;
                return false;
            }
        }
        else if (paramName == "max-mem-per-proc") {
            iss >> maxMemPerProc;
            if (!isInValidRange(maxMemPerProc) || !isPowerOfTwo(maxMemPerProc)) {
                std::cerr << "Invalid max-mem-per-proc in " << filename << ": must be power of 2 in range [2, 2^32]" << std::endl;
                return false;
            }
            if (maxMemPerProc < minMemPerProc) {
                std::cerr << "Invalid max-mem-per-proc in " << filename << ": must be greater than or equal to min-mem-per-proc" << std::endl;
                return false;
            }
        }
        else {
            std::cerr << "Unknown parameter in " << filename << ": " << paramName << std::endl;
            return false;
        }
    }

    configFile.close();
    return true;
}

std::string Config::stripQuotes(const std::string& str) {
    if (str.size() >= 2 &&
        ((str.front() == '"' && str.back() == '"') ||
            (str.front() == '\'' && str.back() == '\''))) {
        return str.substr(1, str.size() - 2);
    }
    return str;
}

int Config::getNumCpu() const {
    return numCpu;
}

const std::string& Config::getSchedulerType() const {
    return schedulerType;
}

unsigned int Config::getQuantumCycles() const {
    return quantumCycles;
}

unsigned int Config::getBatchProcessFreq() const {
    return batchProcessFreq;
}

unsigned int Config::getMinIns() const {
    return minIns;
}

unsigned int Config::getMaxIns() const {
    return maxIns;
}

unsigned int Config::getDelaysPerExec() const {
    return delaysPerExec;
}

unsigned int Config::getMaxOverallMem() const {
    return maxOverallMem;
}

unsigned int Config::getMemPerFrame() const {
    return memPerFrame;
}

unsigned int Config::getMinMemPerProc() const {
    return minMemPerProc;
}

unsigned int Config::getMaxMemPerProc() const {
    return maxMemPerProc;
}

--------------------------------------------------
File End
--------------------------------------------------


./src\Config.h
File type: .h
#pragma once

#include <string>

class Config {
public:
    static Config& getInstance();

    bool loadConfig(const std::string& filename);

    int getNumCpu() const;
    const std::string& getSchedulerType() const;
    unsigned int getQuantumCycles() const;
    unsigned int getBatchProcessFreq() const;
    unsigned int getMinIns() const;
    unsigned int getMaxIns() const;
    unsigned int getDelaysPerExec() const;
    unsigned int getMaxOverallMem() const;
    unsigned int getMemPerFrame() const;
    unsigned int getMinMemPerProc() const;
    unsigned int getMaxMemPerProc() const;

private:
    Config();
    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;

    std::string stripQuotes(const std::string& str);
    static bool isPowerOfTwo(unsigned int x);
    static bool isInValidRange(unsigned int x);

    int numCpu;
    std::string schedulerType;
    unsigned int quantumCycles;
    unsigned int batchProcessFreq;
    unsigned int minIns;
    unsigned int maxIns;
    unsigned int delaysPerExec;
    unsigned int maxOverallMem;
    unsigned int memPerFrame;
    unsigned int minMemPerProc;
    unsigned int maxMemPerProc;
};

--------------------------------------------------
File End
--------------------------------------------------


./src\Console.h
File type: .h
#pragma once

class Console {
public:
    virtual void run() = 0;
    virtual ~Console() {}
};

--------------------------------------------------
File End
--------------------------------------------------


./src\ConsoleManager.cpp
File type: .cpp
#include "ConsoleManager.h"
#include "MainConsole.h"
#include "Screen.h"
#include "SchedulerFCFS.h"
#include "SchedulerRR.h"
#include "PrintCommand.h"
#include <iostream>
#include <thread>
#include <chrono>
#include <fstream>
#include <sstream>

ConsoleManager::ConsoleManager()
    : testing(false), initialized(false), scheduler(nullptr), cpuCycles(0), cpuCycleRunning(false) {
    mainConsole = new MainConsole(*this);
}

ConsoleManager::~ConsoleManager() {
    stopSchedulerTest();
    stopCpuCycleCounter();
    if (scheduler) {
        scheduler->stop();
        delete scheduler;
    }
    delete mainConsole;
    for (auto& pair : processes) {
        delete pair.second;
    }
}

bool ConsoleManager::initialize() {
    Config& config = Config::getInstance();
    if (!config.loadConfig("config.txt")) {
        std::cerr << "Failed to load configuration." << std::endl;
        return false;
    }

    memoryManager.initialize(
        config.getMaxOverallMem(),
        config.getMemPerFrame()
    );

    if (config.getSchedulerType() == "fcfs") {
        scheduler = new SchedulerFCFS(config.getNumCpu(), *this);
    }
    else if (config.getSchedulerType() == "rr") {
        scheduler = new SchedulerRR(config.getNumCpu(), config.getQuantumCycles(), *this);
    }
    else {
        std::cerr << "Unknown scheduler type in configuration." << std::endl;
        return false;
    }

    startScheduler();
    startCpuCycleCounter();
    initialized = true;
    return true;
}

bool ConsoleManager::isInitialized() const {
    return initialized;
}

void ConsoleManager::startCpuCycleCounter() {
    std::lock_guard<std::mutex> lock(cpuCycleMutex);
    if (cpuCycleRunning) return;
    cpuCycleRunning = true;
    cpuCycleThread = std::thread(&ConsoleManager::cpuCycleLoop, this);
}

void ConsoleManager::stopCpuCycleCounter() {
    {
        std::lock_guard<std::mutex> lock(cpuCycleMutex);
        if (!cpuCycleRunning) return;
        cpuCycleRunning = false;
    }
    cpuCycleCV.notify_all();
    if (cpuCycleThread.joinable()) {
        cpuCycleThread.join();
    }
}

void ConsoleManager::cpuCycleLoop() {
    while (true) {
        {
            std::unique_lock<std::mutex> lock(cpuCycleMutex);
            if (!cpuCycleRunning) break;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        cpuCycles++;
    }
}

void ConsoleManager::safePrint(const std::string& message) {
    std::lock_guard<std::mutex> lock(ioMutex);
    // Move to new line and print message
    std::cout << "\n" << message << std::endl;
    // Reprint the prompt
    std::cout << currentPrompt;
    std::cout.flush();
}

void ConsoleManager::printPrompt() {
    std::lock_guard<std::mutex> lock(ioMutex);
    std::cout << currentPrompt;
    std::cout.flush();
}

void ConsoleManager::setCurrentPrompt(const std::string& prompt) {
    std::lock_guard<std::mutex> lock(ioMutex);
    currentPrompt = prompt;
}


void ConsoleManager::start() {
    mainConsole->run();
}

void ConsoleManager::switchToMainConsole() {
    system("CLS");
    mainConsole->run();
}

void ConsoleManager::switchToScreen(Process* process) {
    system("CLS");
    Screen screen(*this, process);
    screen.run();
}

bool ConsoleManager::createProcess(const std::string& name) {
    std::lock_guard<std::mutex> lock(processMutex);
    if (processes.find(name) == processes.end()) {
        Process* process = new Process(name);

        // Set memory size for the process
        Config& config = Config::getInstance();
        unsigned int minMem = config.getMinMemPerProc();
        unsigned int maxMem = config.getMaxMemPerProc();
        unsigned int memSize = minMem + rand() % (maxMem - minMem + 1);

        // Validate memory size against total available memory
        if (memSize > config.getMaxOverallMem()) {
            std::cout << "Process memory requirement (" << memSize
                << " KB) exceeds system memory ("
                << config.getMaxOverallMem() << " KB).\n";
            delete process;
            return false;
        }

        process->setMemorySize(memSize);

        // Try to allocate memory for the process
        try {
            if (memoryManager.allocateMemory(process, memSize)) {
                processes[name] = process;
                scheduler->addProcess(process);
                return true;
            }
            else {
                // Not enough memory, cannot create process
                delete process;
                std::cout << "Not enough memory to create process '" << name
                    << "' (required: " << memSize << " KB).\n";
                return false;
            }
        }
        catch (const std::exception& e) {
            delete process;
            std::cout << "Error allocating memory for process '" << name
                << "': " << e.what() << "\n";
            return false;
        }
    }
    else {
        std::cout << "Process with name '" << name << "' already exists.\n";
        return false;
    }
}

Process* ConsoleManager::getProcess(const std::string& name) {
    std::lock_guard<std::mutex> lock(processMutex);
    auto it = processes.find(name);
    if (it != processes.end()) {
        return it->second;
    }
    else {
        std::cout << "No process found with name '" << name << "'.\n";
        return nullptr;
    }
}

std::map<std::string, Process*>& ConsoleManager::getProcesses() {
    return processes;
}

MemoryManager& ConsoleManager::getMemoryManager() {
    return memoryManager;
}

Scheduler* ConsoleManager::getScheduler() {
    return scheduler;
}

void ConsoleManager::startScheduler() {
    if (scheduler->isRunning()) {
        std::cout << "Scheduler is already running.\n";
        return;
    }
    scheduler->start();
    std::cout << "Scheduler started.\n";
}

void ConsoleManager::stopScheduler() {
    if (!scheduler) {
        std::cout << "Scheduler is not initialized.\n";
        return;
    }
    if (!scheduler->isRunning()) {
        std::cout << "Scheduler is not running.\n";
        return;
    }
    scheduler->stop();
    std::cout << "Scheduler stopped.\n";
}

void ConsoleManager::pauseScheduler() {
    if (!scheduler->isRunning()) {
        std::cout << "Scheduler is not running.\n";
        return;
    }
    if (scheduler->isPaused()) {
        std::cout << "Scheduler is already paused.\n";
        return;
    }
    scheduler->pause();
    std::cout << "Scheduler paused.\n";
}

void ConsoleManager::resumeScheduler() {
    if (!scheduler->isRunning()) {
        std::cout << "Scheduler is not running.\n";
        return;
    }
    if (!scheduler->isPaused()) {
        std::cout << "Scheduler is not paused.\n";
        return;
    }
    scheduler->resume();
    std::cout << "Scheduler resumed.\n";
}

void ConsoleManager::startSchedulerTest() {
    std::lock_guard<std::mutex> lock(testMutex);
    if (testing) {
        std::cout << "Scheduler test is already running.\n";
        return;
    }
    if (!scheduler->isRunning()) {
        std::cout << "Scheduler is not running. Starting scheduler.\n";
        startScheduler();
    }
    testing = true;
    testThread = std::thread(&ConsoleManager::schedulerTestLoop, this);

    int batchProcessFreq = Config::getInstance().getBatchProcessFreq();
    std::cout << "Scheduler test started. Generating dummy processes every " << batchProcessFreq << " CPU cycles...\n";
}

void ConsoleManager::stopSchedulerTest() {
    {
        std::lock_guard<std::mutex> lock(testMutex);
        if (!testing) {
            std::cout << "Scheduler test is not running.\n";
            return;
        }
        testing = false;
        testCV.notify_all();
    }
    if (testThread.joinable()) {
        testThread.join();
        std::cout << "Scheduler test stopped.\n";
    }
}

void ConsoleManager::schedulerTestLoop() {
    Config& config = Config::getInstance();
    int processCounter = 1;
    unsigned int freq = config.getBatchProcessFreq();
    unsigned int nextProcessCycle = cpuCycles.load() + freq;

    while (true) {
        {
            std::unique_lock<std::mutex> lock(testMutex);
            if (!testing) break;
        }

        // Wait until cpuCycles >= nextProcessCycle
        while (cpuCycles.load() < nextProcessCycle) {
            {
                std::unique_lock<std::mutex> lock(testMutex);
                if (!testing) return;
            }
        }

        // Generate a new dummy process
        std::string processName = "dummyProcess" + std::to_string(processCounter++);
        if (createProcess(processName)) {
            Process* process = getProcess(processName);
            unsigned int numIns = config.getMinIns() + rand() % (config.getMaxIns() - config.getMinIns() + 1);
            for (unsigned int j = 0; j < numIns; ++j) {
                process->addCommand(new PrintCommand("Hello from " + processName + " Instruction " + std::to_string(j + 1)));
            }
        }
        else {
            std::cout << "Failed to create process '" << processName << "'. Skipping...\n";
        }

        nextProcessCycle += freq;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}


void ConsoleManager::startScheduler10() {
    std::lock_guard<std::mutex> lock(testMutex);
    // Generate 10 processes, each with 100 print commands
    for (int i = 1; i <= 10; ++i) {
        std::string processName = "process" + std::to_string(i);
        createProcess(processName);

        Process* process = getProcess(processName);
        for (int j = 1; j <= 100; ++j) {
            process->addCommand(new PrintCommand("Message " + std::to_string(j) + " from " + processName));
        }

        std::cout << "Generated process: " << processName << " with 100 print commands.\n";
    }
}

std::mutex& ConsoleManager::getIOMutex() {
    return ioMutex;
}

--------------------------------------------------
File End
--------------------------------------------------


./src\ConsoleManager.h
File type: .h
#pragma once

#include "Config.h"
#include "Console.h"
#include "Process.h"
#include "Scheduler.h"
#include "MemoryManager.h"
#include <map>
#include <mutex>
#include <string>
#include <thread>
#include <condition_variable>
#include <atomic>

class MainConsole;

class ConsoleManager {
public:
    ConsoleManager();
    ~ConsoleManager();

    void startCpuCycleCounter();
    void stopCpuCycleCounter();

    void start();
    void switchToMainConsole();
    void switchToScreen(Process* process);

    bool createProcess(const std::string& name);
    Process* getProcess(const std::string& name);
    std::map<std::string, Process*>& getProcesses();

    MemoryManager& getMemoryManager();
    Scheduler* getScheduler();

    void startScheduler();
    void stopScheduler();
    void pauseScheduler();
    void resumeScheduler();

    void startSchedulerTest();
    void stopSchedulerTest();
    void startScheduler10();

    // Console output management
    void safePrint(const std::string& message);
    void printPrompt();
    void setCurrentPrompt(const std::string& prompt);
    std::mutex& getIOMutex();

    bool isInitialized() const;
    bool initialize();

private:
    MainConsole* mainConsole;
    std::map<std::string, Process*> processes;
    std::mutex processMutex;

    // For CPU cycle functionality
    std::atomic<unsigned int> cpuCycles;
    std::thread cpuCycleThread;
    bool cpuCycleRunning;
    std::mutex cpuCycleMutex;
    std::condition_variable cpuCycleCV;
    void cpuCycleLoop();

    MemoryManager memoryManager;
    Scheduler* scheduler;

    // For scheduler test
    void schedulerTestLoop();
    std::thread testThread;
    bool testing;
    std::mutex testMutex;
    std::condition_variable testCV;

    // Console output management
    std::string currentPrompt;
    std::mutex ioMutex;

    bool initialized;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\MainConsole.cpp
File type: .cpp
#include "MainConsole.h"
#include "ConsoleManager.h"
#include "Process.h"
#include "Screen.h"
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <ctime>

MainConsole::MainConsole(ConsoleManager& manager)
    : consoleManager(manager) {}

void MainConsole::run() {
    consoleManager.setCurrentPrompt("Main> ");
    std::string input;
    while (true) {
        consoleManager.printPrompt();
        std::getline(std::cin, input);

        if (input == "exit") {
            if (consoleManager.isInitialized()) {
                consoleManager.stopSchedulerTest();
                consoleManager.stopScheduler();
            }
            break;
        }
        else if (input == "clear") {
            system("CLS");
        }
        else {
            handleCommand(input);
        }
    }
}

void MainConsole::handleCommand(const std::string& input) {
    if (!consoleManager.isInitialized()) {
        if (input == "initialize") {
            if (!consoleManager.initialize()) {
                std::cout << "Failed to initialize system." << std::endl;
            }
            else {
                std::cout << "System initialized successfully with "
                    << "\"" << Config::getInstance().getSchedulerType() << "\""
                    << " scheduler." << std::endl;
            }
        }
        else if (input == "exit") {
            // Exit is handled in the main loop
        }
        else {
            std::cout << "System not initialized. Please run 'initialize' command first." << std::endl;
        }
        return;
    }

    std::istringstream iss(input);
    std::vector<std::string> tokens;
    std::string token;
    while (iss >> token) {
        tokens.push_back(token);
    }

    if (tokens.empty()) {
        std::cout << "No command entered.\n";
        return;
    }

    std::string command = tokens[0];

    if (command == "screen") {
        if (tokens.size() < 2) {
            std::cout << "Invalid usage of screen command.\n";
            return;
        }
        std::string flag = tokens[1];

        if (flag == "-s") {
            if (tokens.size() >= 3) {
                std::string processName = tokens[2];
                consoleManager.createProcess(processName);
                std::cout << "Process '" << processName << "' created.\n";
            }
            else {
                std::cout << "Please specify a process name.\n";
            }
        }
        else if (flag == "-r") {
            if (tokens.size() >= 3) {
                std::string processName = tokens[2];
                Process* process = consoleManager.getProcess(processName);
                if (process) {
                    consoleManager.switchToScreen(process);
                }
            }
            else {
                std::cout << "Please specify a process name to resume.\n";
            }
        }
        else if (flag == "-ls") {
            bool showAll = false;
            if (tokens.size() >= 3 && tokens[2] == "-a") {
                showAll = true;
            }

            Scheduler* scheduler = consoleManager.getScheduler();
            if (!scheduler) {
                std::cout << "Scheduler is not initialized.\n";
                return;
            }

            auto runningProcessesMap = scheduler->getRunningProcesses();
            auto queuedProcesses = scheduler->getQueuedProcesses();
            auto finishedProcesses = scheduler->getFinishedProcesses();

            std::vector<Process*> runningProcesses;
            for (const auto& pair : runningProcessesMap) {
                runningProcesses.push_back(pair.first);
            }

            // Display CPU utilization and core information
            int totalCores = scheduler->getTotalCores();
            int busyCores = scheduler->getBusyCores();
            int availableCores = totalCores - busyCores;
            double cpuUtilization = ((double)busyCores / totalCores) * 100.0;

            std::cout << "\nCPU utilization: " << std::fixed << std::setprecision(2) << cpuUtilization << "%\n";
            std::cout << "Cores used: " << busyCores << "\n";
            std::cout << "Cores available: " << availableCores << "\n";

            std::cout << "\n-------------------------------------------------------";

            if (showAll) {
                displayQueuedProcesses(queuedProcesses);
            }

            displayRunningProcesses(runningProcesses, runningProcessesMap);

            displayFinishedProcesses(finishedProcesses);

            std::cout << "-------------------------------------------------------\n\n";
        }
        else {
            std::cout << "Invalid flag for screen command.\n";
            std::cout << "Usage:\n";
            std::cout << "  screen -s [process_name]       : Start a new process\n";
            std::cout << "  screen -r [process_name]       : Resume an existing process\n";
            std::cout << "  screen -ls                     : List running and finished processes\n";
            std::cout << "  screen -ls -a                  : List all processes including queued\n";
        }
    }
    else if (command == "process-smi") {
        displayProcessSmi();
    }
    else if (command == "vmstat") {
        displayVmStat();
    }
    else if (command == "scheduler-pause") {
        consoleManager.pauseScheduler();
    }
    else if (command == "scheduler-resume") {
        consoleManager.resumeScheduler();
    }
    else if (command == "scheduler-10") {
        consoleManager.startScheduler10();
    }
    else if (command == "scheduler-test") {
        consoleManager.startSchedulerTest();
    }
    else if (command == "scheduler-stop") {
        consoleManager.stopSchedulerTest();
    }
    else if (command == "report-util") {
        reportUtil();
    }
    else if (command == "log") {
        if (tokens.size() >= 2) {
            std::string option = tokens[1];
            if (option == "on") {
                Process::setLoggingEnabled(true);
                std::cout << "Process logging enabled.\n";
            }
            else if (option == "off") {
                Process::setLoggingEnabled(false);
                std::cout << "Process logging disabled.\n";
            }
            else {
                std::cout << "Usage: log [on|off]\n";
            }
        }
        else {
            std::cout << "Usage: log [on|off]\n";
        }
    }
    else if (command == "initialize") {
        std::cout << "System is already initialized.\n";
    }
    else {
        std::cout << "Command not recognized. Please try again.\n";
    }
}

void MainConsole::displayProcessSmi() {
    MemoryManager& memoryManager = consoleManager.getMemoryManager();
    Scheduler* scheduler = consoleManager.getScheduler();
    if (!scheduler) {
        std::cout << "Scheduler is not initialized.\n";
        return;
    }

    std::cout << "\n+---------------------------------------------+\n";
    std::cout << "|          PROCESS-SMI V01.00 Monitor         |\n";
    std::cout << "+---------------------------------------------+\n";

    // System Utilization Section
    double cpuUtilization = ((double)scheduler->getBusyCores() / scheduler->getTotalCores()) * 100.0;
    unsigned int totalMem = memoryManager.getTotalMemory();
    unsigned int usedMem = memoryManager.getUsedMemory();
    double memUtil = memoryManager.getMemoryUtilization();

    std::stringstream usedMemStr, totalMemStr;
    usedMemStr << usedMem << " KB";
    totalMemStr << totalMem << " KB";

    std::cout << "| System Utilization                          |\n";
    std::cout << "| CPU Usage    : " << std::right << std::setw(9) << std::fixed << std::setprecision(1)
        << cpuUtilization << "%" << std::string(19, ' ') << "|\n";
    std::cout << "| Memory       : " << std::right << std::setw(10) << usedMemStr.str() << " / "
        << std::left << std::setw(7) << totalMemStr.str() << std::string(9, ' ') << "|\n";
    std::cout << "| Memory Usage : " << std::right << std::setw(9) << std::fixed << std::setprecision(1)
        << memUtil << "%" << std::string(19, ' ') << "|\n";

    // Process Memory Section
    std::cout << "+---------------------------------------------+\n";
    std::cout << "|   PID   Process Name          Memory Usage  |\n";
    std::cout << "|---------------------------------------------|\n";

    auto processesInMemory = memoryManager.getProcessesInMemory();
    for (const auto& entry : processesInMemory) {
        Process* process = entry.first;
        std::string processName = process->getName();
        if (processName.length() > 16) {
            processName = processName.substr(0, 13) + "...";
        }
        std::cout << "| " << std::setw(5) << process->getId() << "   "
            << std::left << std::setw(16) << processName << " "
            << std::right << std::setw(9) << entry.second << " KB"
            << std::string(7, ' ') << "|\n";
    }

    if (processesInMemory.empty()) {
        std::cout << "| No processes currently in memory"
            << std::string(12, ' ') << "|\n";
    }

    std::cout << "+---------------------------------------------+\n\n";
}

void MainConsole::displayVmStat() {
    MemoryManager& memoryManager = consoleManager.getMemoryManager();

    std::cout << "\n+--------------------------------+\n";
    std::cout << "|      Virtual Memory Stats      |\n";
    std::cout << "+--------------------------------+\n";
    std::cout << "| Memory Summary:                |\n";
    std::cout << "| Total Memory  : " << std::right << std::setw(10) << memoryManager.getTotalMemory()
        << " KB" << std::string(2, ' ') << "|\n";
    std::cout << "| Used Memory   : " << std::right << std::setw(10) << memoryManager.getUsedMemory()
        << " KB" << std::string(2, ' ') << "|\n";
    std::cout << "| Free Memory   : " << std::right << std::setw(10) << memoryManager.getFreeMemory()
        << " KB" << std::string(2, ' ') << "|\n";

    std::cout << "+--------------------------------+\n";
    std::cout << "| CPU Statistics:                |\n";
    std::cout << "| Idle Ticks    : " << std::right << std::setw(13) << memoryManager.getIdleCpuTicks()
        << std::string(2, ' ') << "|\n";
    std::cout << "| Active Ticks  : " << std::right << std::setw(13) << memoryManager.getActiveCpuTicks()
        << std::string(2, ' ') << "|\n";
    std::cout << "| Total Ticks   : " << std::right << std::setw(13) << memoryManager.getTotalCpuTicks()
        << std::string(2, ' ') << "|\n";

    if (memoryManager.isPaging()) {
        std::cout << "+--------------------------------+\n";
        std::cout << "| Paging Information:            |\n";
        std::cout << "| Pages In      : " << std::right << std::setw(13) << memoryManager.getNumPagedIn()
            << std::string(2, ' ') << "|\n";
        std::cout << "| Pages Out     : " << std::right << std::setw(13) << memoryManager.getNumPagedOut()
            << std::string(2, ' ') << "|\n";
    }

    std::cout << "+--------------------------------+\n\n";
}

void MainConsole::displayRunningProcesses(const std::vector<Process*>& runningProcesses, const std::map<Process*, int>& runningProcessesMap) {
    if (runningProcesses.empty()) {
        std::cout << "\nNo running processes.\n";
        return;
    }
    std::cout << "\nRunning processes:\n";

    for (Process* process : runningProcesses) {
        int coreId = runningProcessesMap.at(process);
        std::string processName = process->getName();
        std::time_t creationTime = process->getCreationTime();
        std::tm creationTm;

        localtime_s(&creationTm, &creationTime);

        char timeBuffer[30];
        std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
        std::string timeStr = timeBuffer;

        int currentLine = process->getCurrentLine();
        int totalLines = process->getTotalLines();

        // Format: processName  (creationTime)  Core: coreId   currentLine / totalLines
        std::cout << std::left << std::setw(15) << processName
            << "(" << timeStr << ")    "
            << "Core: " << coreId << "     "
            << currentLine << " / " << totalLines << "\n";
    }
}

void MainConsole::displayFinishedProcesses(const std::vector<Process*>& finishedProcesses) {
    if (finishedProcesses.empty()) {
        std::cout << "\nNo finished processes.\n";
        return;
    }
    std::cout << "\nFinished processes:\n";
    for (Process* process : finishedProcesses) {
        std::string processName = process->getName();
        std::time_t creationTime = process->getCreationTime();
        std::tm creationTm;

        localtime_s(&creationTm, &creationTime);

        char timeBuffer[30];
        std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
        std::string timeStr = timeBuffer;

        int totalLines = process->getTotalLines();

        // Format: processName  (creationTime)  Finished   totalLines / totalLines
        std::cout << std::left << std::setw(15) << processName
            << "(" << timeStr << ")    "
            << "Finished     "
            << totalLines << " / " << totalLines << "\n";
    }
}

void MainConsole::displayQueuedProcesses(const std::vector<Process*>& queuedProcesses) {
    if (queuedProcesses.empty()) {
        std::cout << "\nNo queued processes.\n";
        return;
    }
    std::cout << "\nQueued processes:\n";
    for (Process* process : queuedProcesses) {
        std::string processName = process->getName();
        std::time_t creationTime = process->getCreationTime();
        std::tm creationTm;

        localtime_s(&creationTm, &creationTime);

        char timeBuffer[30];
        std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
        std::string timeStr = timeBuffer;

        int currentLine = process->getCurrentLine();
        int totalLines = process->getTotalLines();

        // Format: processName  (creationTime)  Queued   currentLine / totalLines
        std::cout << std::left << std::setw(15) << processName
            << "(" << timeStr << ")    "
            << "Queued     "
            << currentLine << " / " << totalLines << "\n";
    }
}

void MainConsole::reportUtil() {
    Scheduler* scheduler = consoleManager.getScheduler();
    if (!scheduler) {
        std::cout << "Scheduler is not initialized.\n";
        return;
    }

    auto runningProcessesMap = scheduler->getRunningProcesses();
    auto queuedProcesses = scheduler->getQueuedProcesses();
    auto finishedProcesses = scheduler->getFinishedProcesses();

    std::vector<Process*> runningProcesses;
    for (const auto& pair : runningProcessesMap) {
        runningProcesses.push_back(pair.first);
    }

    std::ofstream logfile("csopesy-log.txt", std::ios::app);

    if (!logfile.is_open()) {
        std::cout << "Failed to open csopesy-log.txt for writing.\n";
        return;
    }

    std::time_t now = std::time(nullptr);
    char buffer[26];
    ctime_s(buffer, sizeof(buffer), &now);
    logfile << "Report generated at: " << buffer << "\n";

    // Display CPU utilization and core information
    int totalCores = scheduler->getTotalCores();
    int busyCores = scheduler->getBusyCores();
    int availableCores = totalCores - busyCores;
    double cpuUtilization = ((double)busyCores / totalCores) * 100.0;

    logfile << "CPU utilization: " << std::fixed << std::setprecision(2) << cpuUtilization << "%\n";
    logfile << "Cores used: " << busyCores << "\n";
    logfile << "Cores available: " << availableCores << "\n";

    logfile << "\n-------------------------------------------------------";

    // Display queued processes
    if (!queuedProcesses.empty()) {
        logfile << "\nQueued processes:\n";
        for (Process* process : queuedProcesses) {
            std::string processName = process->getName();
            std::time_t creationTime = process->getCreationTime();
            std::tm creationTm;

            localtime_s(&creationTm, &creationTime);

            char timeBuffer[30];
            std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
            std::string timeStr = timeBuffer;

            int currentLine = process->getCurrentLine();
            int totalLines = process->getTotalLines();

            // Format: processName  (creationTime)  Queued   currentLine / totalLines
            logfile << std::left << std::setw(15) << processName
                << "(" << timeStr << ")    "
                << "Queued     "
                << currentLine << " / " << totalLines << "\n";
        }
    }
    else {
        logfile << "\nNo queued processes.\n";
    }

    // Display running processes
    if (!runningProcesses.empty()) {
        logfile << "\nRunning processes:\n";
        for (Process* process : runningProcesses) {
            int coreId = runningProcessesMap.at(process);
            std::string processName = process->getName();
            std::time_t creationTime = process->getCreationTime();
            std::tm creationTm;

            localtime_s(&creationTm, &creationTime);

            char timeBuffer[30];
            std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
            std::string timeStr = timeBuffer;

            int currentLine = process->getCurrentLine();
            int totalLines = process->getTotalLines();

            // Format: processName  (creationTime)  Core: coreId   currentLine / totalLines
            logfile << std::left << std::setw(15) << processName
                << "(" << timeStr << ")    "
                << "Core: " << coreId << "     "
                << currentLine << " / " << totalLines << "\n";
        }
    }
    else {
        logfile << "\nNo running processes.\n";
    }

    // Display finished processes
    if (!finishedProcesses.empty()) {
        logfile << "\nFinished processes:\n";
        for (Process* process : finishedProcesses) {
            std::string processName = process->getName();
            std::time_t creationTime = process->getCreationTime();
            std::tm creationTm;

            localtime_s(&creationTm, &creationTime);

            char timeBuffer[30];
            std::strftime(timeBuffer, sizeof(timeBuffer), "%m/%d/%Y %I:%M:%S%p", &creationTm);
            std::string timeStr = timeBuffer;

            int totalLines = process->getTotalLines();

            // Format: processName  (creationTime)  Finished   totalLines / totalLines
            logfile << std::left << std::setw(15) << processName
                << "(" << timeStr << ")    "
                << "Finished     "
                << totalLines << " / " << totalLines << "\n";
        }
    }
    else {
        logfile << "\nNo finished processes.\n";
    }

    logfile << "-------------------------------------------------------\n\n\n";
    logfile.close();
    std::cout << "Utilization report saved to csopesy-log.txt.\n";
}

--------------------------------------------------
File End
--------------------------------------------------


./src\MainConsole.h
File type: .h
#pragma once

#include "Console.h"
#include <string>
#include <vector>
#include <map>

class ConsoleManager;
class Process;

class MainConsole : public Console {
public:
    MainConsole(ConsoleManager& manager);
    void run() override;

private:
    void handleCommand(const std::string& input);

    void displayProcessSmi();
    void displayVmStat();
    void displayRunningProcesses(const std::vector<Process*>& runningProcesses, const std::map<Process*, int>& runningProcessesMap);
    void displayFinishedProcesses(const std::vector<Process*>& finishedProcesses);
    void displayQueuedProcesses(const std::vector<Process*>& queuedProcesses);

    void reportUtil();

    ConsoleManager& consoleManager;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\MemoryManager.cpp
File type: .cpp
#include "MemoryManager.h"
#include <algorithm>

MemoryManager::MemoryManager()
    : maxMemory(0), memPerFrame(0), totalFrames(0), flatMemory(true),
    usedMemory(0), numPagedIn(0), numPagedOut(0),
    idleCpuTicks(0), activeCpuTicks(0), totalCpuTicks(0) {}

MemoryManager::~MemoryManager() {}

void MemoryManager::initialize(unsigned int maxMem, unsigned int memPerFrame) {
    std::lock_guard<std::mutex> lock(memoryMutex);

    maxMemory = maxMem;
    this->memPerFrame = memPerFrame;
    totalFrames = maxMemory / memPerFrame;
    flatMemory = (maxMemory == memPerFrame);

    if (flatMemory) {
        // Initialize single block of free memory
        memoryBlocks.clear();
        memoryBlocks.push_back({ 0, maxMemory, nullptr });
    }
    else {
        // Initialize frames for paging
        frames.resize(totalFrames);
        for (auto& frame : frames) {
            frame.allocated = false;
            frame.owner = nullptr;
            frame.pageNumber = -1;
        }
    }
}

void MemoryManager::compactMemory() {
    if (!flatMemory) return;

    std::vector<MemoryBlock> newBlocks;
    size_t currentOffset = 0;

    // Move all allocated blocks to the front
    for (const auto& block : memoryBlocks) {
        if (block.process != nullptr) {
            newBlocks.push_back({ currentOffset, block.size, block.process });
            currentOffset += block.size;
        }
    }

    // Add remaining space as a single free block
    if (currentOffset < maxMemory) {
        newBlocks.push_back({ currentOffset, maxMemory - currentOffset, nullptr });
    }

    memoryBlocks = std::move(newBlocks);
}

bool MemoryManager::findFreeFrames(unsigned int numFramesNeeded, std::vector<int>& frameNumbers) {
    frameNumbers.clear();
    for (size_t i = 0; i < frames.size() && frameNumbers.size() < numFramesNeeded; ++i) {
        if (!frames[i].allocated) {
            frameNumbers.push_back(i);
        }
    }
    return frameNumbers.size() == numFramesNeeded;
}

void MemoryManager::removeOldestProcess() {
    if (memoryQueue.empty()) return;

    Process* oldestProcess = memoryQueue.front();
    memoryQueue.pop_front();

    if (flatMemory) {
        for (auto& block : memoryBlocks) {
            if (block.process == oldestProcess) {
                block.process = nullptr;
                usedMemory -= block.size;
            }
        }
        compactMemory();
    }
    else {
        auto it = pageTables.find(oldestProcess);
        if (it != pageTables.end()) {
            for (const auto& entry : it->second) {
                if (entry.present) {
                    frames[entry.frameNumber].allocated = false;
                    frames[entry.frameNumber].owner = nullptr;
                    frames[entry.frameNumber].pageNumber = -1;
                    numPagedOut++;
                }
            }
            pageTables.erase(it);
        }
    }

    oldestProcess->setInMemory(false);
}

bool MemoryManager::allocateMemory(Process* process, unsigned int size) {
    std::lock_guard<std::mutex> lock(memoryMutex);

    if (size > maxMemory) {
        return false;
    }

    if (flatMemory) {
        // First, try to find a suitable free block
        for (auto& block : memoryBlocks) {
            if (block.process == nullptr && block.size >= size) {
                // Split block if it's larger than needed
                if (block.size > size) {
                    memoryBlocks.push_back({
                        block.offset + size,
                        block.size - size,
                        nullptr
                        });
                }
                block.size = size;
                block.process = process;
                usedMemory += size;
                memoryQueue.push_back(process);
                process->setInMemory(true);
                return true;
            }
        }

        // If no suitable block found, try to free up space
        while (getFreeMemory() < size && !memoryQueue.empty()) {
            removeOldestProcess();
            compactMemory();
        }

        // Try allocation again
        if (getFreeMemory() >= size) {
            for (auto& block : memoryBlocks) {
                if (block.process == nullptr && block.size >= size) {
                    if (block.size > size) {
                        memoryBlocks.push_back({
                            block.offset + size,
                            block.size - size,
                            nullptr
                            });
                    }
                    block.size = size;
                    block.process = process;
                    usedMemory += size;
                    memoryQueue.push_back(process);
                    process->setInMemory(true);
                    return true;
                }
            }
        }
    }
    else {
        // Paging allocation
        unsigned int numPages = (size + memPerFrame - 1) / memPerFrame;
        std::vector<int> freeFrames;

        while (!findFreeFrames(numPages, freeFrames) && !memoryQueue.empty()) {
            removeOldestProcess();
        }

        if (findFreeFrames(numPages, freeFrames)) {
            std::vector<PageTableEntry> pageTable(numPages);
            for (size_t i = 0; i < numPages; ++i) {
                int frameNum = freeFrames[i];
                frames[frameNum].allocated = true;
                frames[frameNum].owner = process;
                frames[frameNum].pageNumber = i;

                pageTable[i].frameNumber = frameNum;
                pageTable[i].present = true;
                numPagedIn++;
            }

            pageTables[process] = std::move(pageTable);
            memoryQueue.push_back(process);
            process->setInMemory(true);
            return true;
        }
    }

    return false;
}

void MemoryManager::deallocateMemory(Process* process) {
    std::lock_guard<std::mutex> lock(memoryMutex);

    if (flatMemory) {
        for (auto& block : memoryBlocks) {
            if (block.process == process) {
                usedMemory -= block.size;
                block.process = nullptr;
            }
        }
        compactMemory();
    }
    else {
        auto it = pageTables.find(process);
        if (it != pageTables.end()) {
            for (const auto& entry : it->second) {
                if (entry.present) {
                    frames[entry.frameNumber].allocated = false;
                    frames[entry.frameNumber].owner = nullptr;
                    frames[entry.frameNumber].pageNumber = -1;
                }
            }
            pageTables.erase(it);
        }
    }

    memoryQueue.remove(process);
    process->setInMemory(false);
}

unsigned int MemoryManager::getUsedMemory() const {
    std::lock_guard<std::mutex> lock(memoryMutex);

    if (flatMemory) {
        return usedMemory;
    }
    else {
        unsigned int usedFrames = 0;
        for (const auto& frame : frames) {
            if (frame.allocated) {
                usedFrames++;
            }
        }
        return usedFrames * memPerFrame;
    }
}

unsigned int MemoryManager::getTotalMemory() const {
    return maxMemory;
}

unsigned int MemoryManager::getFreeMemory() const {
    return getTotalMemory() - getUsedMemory();
}

double MemoryManager::getMemoryUtilization() const {
    return (static_cast<double>(getUsedMemory()) / getTotalMemory()) * 100.0;
}

std::vector<std::pair<Process*, unsigned int>> MemoryManager::getProcessesInMemory() const {
    std::lock_guard<std::mutex> lock(memoryMutex);
    std::vector<std::pair<Process*, unsigned int>> result;

    if (flatMemory) {
        std::map<Process*, unsigned int> processMemory;
        for (const auto& block : memoryBlocks) {
            if (block.process != nullptr) {
                processMemory[block.process] += block.size;
            }
        }
        for (const auto& pair : processMemory) {
            result.emplace_back(pair.first, pair.second);
        }
    }
    else {
        for (const auto& pair : pageTables) {
            unsigned int numPages = 0;
            for (const auto& entry : pair.second) {
                if (entry.present) numPages++;
            }
            result.emplace_back(pair.first, numPages * memPerFrame);
        }
    }

    return result;
}

bool MemoryManager::isProcessInMemory(Process* process) const {
    std::lock_guard<std::mutex> lock(memoryMutex);
    return std::find(memoryQueue.begin(), memoryQueue.end(), process) != memoryQueue.end();
}

bool MemoryManager::isPaging() const {
    return !flatMemory;
}

unsigned int MemoryManager::getIdleCpuTicks() const {
    return idleCpuTicks;
}

unsigned int MemoryManager::getActiveCpuTicks() const {
    return activeCpuTicks;
}

unsigned int MemoryManager::getTotalCpuTicks() const {
    return totalCpuTicks;
}

unsigned int MemoryManager::getNumPagedIn() const {
    return numPagedIn;
}

unsigned int MemoryManager::getNumPagedOut() const {
    return numPagedOut;
}

void MemoryManager::incrementIdleCpuTicks() {
    std::lock_guard<std::mutex> lock(memoryMutex);
    idleCpuTicks++;
    totalCpuTicks++;
}

void MemoryManager::incrementActiveCpuTicks() {
    std::lock_guard<std::mutex> lock(memoryMutex);
    activeCpuTicks++;
    totalCpuTicks++;
}

--------------------------------------------------
File End
--------------------------------------------------


./src\MemoryManager.h
File type: .h
#pragma once

#include <map>
#include <list>
#include <mutex>
#include <vector>
#include "Process.h"

struct MemoryBlock {
    size_t offset;
    size_t size;
    Process* process;
};

struct Frame {
    bool allocated;
    Process* owner;
    int pageNumber;
};

struct PageTableEntry {
    int frameNumber;
    bool present;
};

class MemoryManager {
public:
    MemoryManager();
    ~MemoryManager();

    void initialize(unsigned int maxMem, unsigned int memPerFrame);
    bool allocateMemory(Process* process, unsigned int size);
    void deallocateMemory(Process* process);

    unsigned int getTotalMemory() const;
    unsigned int getUsedMemory() const;
    unsigned int getFreeMemory() const;
    double getMemoryUtilization() const;

    unsigned int getIdleCpuTicks() const;
    unsigned int getActiveCpuTicks() const;
    unsigned int getTotalCpuTicks() const;
    unsigned int getNumPagedIn() const;
    unsigned int getNumPagedOut() const;

    void incrementIdleCpuTicks();
    void incrementActiveCpuTicks();

    std::vector<std::pair<Process*, unsigned int>> getProcessesInMemory() const;
    bool isProcessInMemory(Process* process) const;
    bool isPaging() const;

private:
    void compactMemory();
    bool findFreeFrames(unsigned int numFramesNeeded, std::vector<int>& frameNumbers);
    void removeOldestProcess();

    mutable std::mutex memoryMutex;
    unsigned int maxMemory;
    unsigned int memPerFrame;
    unsigned int totalFrames;
    bool flatMemory;

    // For flat memory allocation
    std::vector<MemoryBlock> memoryBlocks;
    unsigned int usedMemory;

    // For paging allocation
    std::vector<Frame> frames;
    std::map<Process*, std::vector<PageTableEntry>> pageTables;

    std::list<Process*> memoryQueue;
    unsigned int numPagedIn;
    unsigned int numPagedOut;
    unsigned int idleCpuTicks;
    unsigned int activeCpuTicks;
    unsigned int totalCpuTicks;
};

--------------------------------------------------
File End
--------------------------------------------------


./src\OSEmulator.cpp
File type: .cpp
#include "ConsoleManager.h"
#include <iostream>

int main() {
    std::cout << R"(  _____   _____    _____   _____    _______   _____   __    __ )" << "\n";
    std::cout << R"( / ____| / ____|  /  __ \  |  __ \  |  ____| / ____|  \ \  / / )" << "\n";
    std::cout << R"(| |      | (___   | |  | | | |__) | | |__    | (___    \ \/ /  )" << "\n";
    std::cout << R"(| |       \___ \  | |  | | |  ___/  |  __|    \___ \    |  |   )" << "\n";
    std::cout << R"(| |____   ____) | | |__| | | |      | |____   ____) |   |  |   )" << "\n";
    std::cout << R"( \_____| |_____/  \_____/  |_|      |______| |_____/    |__|   )" << "\n";
    std::cout << "--------------------------------------------------------------\n\n";
    std::cout << "Welcome to CSOPESY Emulator!\n\n";
    std::cout << "Developers:\n";
    std::cout << "Gabini, Brian\n";
    std::cout << "Recato Dy, John Kieffer\n";
    std::cout << "Tan, Timothy Joshua\n";
    std::cout << "Verano, Carl Matthew\n\n";
    std::cout << "Last updated: 11-25-2024\n\n";

    ConsoleManager consoleManager;
    consoleManager.start();
    return 0;
}


--------------------------------------------------
File End
--------------------------------------------------


./src\PrintCommand.cpp
File type: .cpp
#include "PrintCommand.h"
#include "Process.h"
#include <thread>
#include <chrono>
#include "Config.h"

PrintCommand::PrintCommand(const std::string& message)
    : message(message) {}

void PrintCommand::execute(Process* process, int coreId) {
    process->log(message, coreId);
}

std::string PrintCommand::getDescription() const {
    return "print " + message;
}


--------------------------------------------------
File End
--------------------------------------------------


./src\PrintCommand.h
File type: .h
#pragma once

#include "Command.h"

class PrintCommand : public Command {
public:
    PrintCommand(const std::string& message);
    void execute(Process* process, int coreId) override;
    std::string getDescription() const override;

private:
    std::string message;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\Process.cpp
File type: .cpp
#include "Process.h"
#include "Command.h"
#include <fstream>
#include <iostream>
#include <ctime>
#include <iomanip>
#include <mutex>

int Process::nextId = 1;
bool Process::loggingEnabled = false;

Process::Process(const std::string& name)
    : name(name), currentLine(0), totalLines(0), completed(false),
      memorySize(0), inMemory(false) {
    creationTime = std::chrono::system_clock::now();
    id = nextId++;

    if (loggingEnabled) {
        // Initialize process log file only if logging is enabled
        std::ofstream logfile(name + ".txt", std::ios::out);
        if (logfile.is_open()) {
            logfile << "Process name: " << name << "\nLogs:\n";
            logfile.close();
        }
        else {
            std::cerr << "Unable to create log file for process " << name << std::endl;
        }
    }
}

Process::~Process() {
    while (!commandQueue.empty()) {
        delete commandQueue.front();
        commandQueue.pop();
    }
}

int Process::getId() const {
    return id;
}

const std::string& Process::getName() const {
    return name;
}

void Process::setMemorySize(unsigned int size) {
    memorySize = size;
}

unsigned int Process::getMemorySize() const {
    return memorySize;
}

void Process::setInMemory(bool inMemory) {
    this->inMemory = inMemory;
}

bool Process::isInMemory() const {
    return inMemory;
}

void Process::addCommand(Command* cmd) {
    {
        std::lock_guard<std::mutex> lock(queueMutex);
        commandQueue.push(cmd);
    }

    // Store command description for display
    {
        std::lock_guard<std::mutex> lock(stateMutex);
        totalLines++;
        codeLines.push_back(cmd->getDescription());
    }
}

Command* Process::getNextCommand() {
    std::lock_guard<std::mutex> lock(queueMutex);
    if (commandQueue.empty()) {
        return nullptr;
    }
    Command* cmd = commandQueue.front();
    commandQueue.pop();
    return cmd;
}

void Process::log(const std::string& message, int coreId) {
    if (!loggingEnabled) return;

    std::lock_guard<std::mutex> lock(logMutex);
    // Open the process's log file and append the message
    std::ofstream logfile(name + ".txt", std::ios::app);

    if (logfile.is_open()) {
        // Get current time
        std::time_t now = std::time(nullptr);
        std::tm now_tm;

        localtime_s(&now_tm, &now);

        logfile << "(" << std::put_time(&now_tm, "%m/%d/%Y %I:%M:%S%p") << ") ";
        logfile << "Core:" << coreId << " \"" << message << "\"\n";
        logfile.close();
    }
    else {
        std::cerr << "Unable to open log file for process " << name << std::endl;
    }
}

std::time_t Process::getCreationTime() const {
    return std::chrono::system_clock::to_time_t(creationTime);
}

int Process::getCurrentLine() const {
    std::lock_guard<std::mutex> lock(stateMutex);
    return currentLine;
}

int Process::getTotalLines() const {
    std::lock_guard<std::mutex> lock(stateMutex);
    return totalLines;
}

std::string Process::getCurrentCodeLine() const {
    std::lock_guard<std::mutex> lock(stateMutex);
    if (currentLine > 0 && currentLine <= totalLines) {
        return codeLines[currentLine - 1];
    }
    else {
        return "No code line is currently being executed.";
    }
}

bool Process::isCompleted() const {
    std::lock_guard<std::mutex> lock(stateMutex);
    return completed;
}

void Process::incrementCurrentLine() {
    std::lock_guard<std::mutex> lock(stateMutex);
    currentLine++;
}

void Process::setCompleted(bool value) {
    std::lock_guard<std::mutex> lock(stateMutex);
    completed = value;
}

void Process::resetCompleted() {
    std::lock_guard<std::mutex> lock(stateMutex);
    completed = false;
}

void Process::setLoggingEnabled(bool enabled) {
    loggingEnabled = enabled;
}

bool Process::isLoggingEnabled() {
    return loggingEnabled;
}


--------------------------------------------------
File End
--------------------------------------------------


./src\Process.h
File type: .h
#pragma once

#include <string>
#include <queue>
#include <mutex>
#include <chrono>
#include <vector>

class Command;

class Process {
public:
    Process(const std::string& name);
    ~Process();

    const std::string& getName() const;
    int getId() const;

    void setMemorySize(unsigned int size);
    unsigned int getMemorySize() const;

    void setInMemory(bool inMemory);
    bool isInMemory() const;

    void addCommand(Command* cmd);
    Command* getNextCommand();

    void log(const std::string& message, int coreId);

    std::time_t getCreationTime() const;

    int getCurrentLine() const;
    int getTotalLines() const;
    std::string getCurrentCodeLine() const;

    bool isCompleted() const;
    void setCompleted(bool value);
    void resetCompleted();
    void incrementCurrentLine();

    static void setLoggingEnabled(bool enabled);
    static bool isLoggingEnabled();

private:
    std::string name;
    int id;

    static int nextId;

    unsigned int memorySize;
    bool inMemory;

    std::queue<Command*> commandQueue;
    mutable std::mutex queueMutex;

    std::chrono::system_clock::time_point creationTime;

    std::vector<std::string> codeLines;
    int currentLine;
    int totalLines;
    bool completed;

    mutable std::mutex stateMutex;

    std::mutex logMutex;

    static bool loggingEnabled;
};

--------------------------------------------------
File End
--------------------------------------------------


./src\Scheduler.h
File type: .h
#pragma once

#include <map>
#include <vector>
#include "Process.h"

class Process;

class Scheduler {
public:
    virtual ~Scheduler() = default;
    virtual void addProcess(Process* process) = 0;
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual void pause() = 0;
    virtual void resume() = 0;
    virtual bool isRunning() const = 0;
    virtual bool isPaused() const = 0;

    virtual int getTotalCores() const = 0;
    virtual int getBusyCores() const = 0;

    virtual std::map<Process*, int> getRunningProcesses() const = 0;
    virtual std::vector<Process*> getQueuedProcesses() const = 0;
    virtual std::vector<Process*> getFinishedProcesses() const = 0;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\SchedulerFCFS.cpp
File type: .cpp
#include "SchedulerFCFS.h"
#include "Command.h"
#include "Config.h"
#include <iostream>
#include <thread>
#include <algorithm>

SchedulerFCFS::SchedulerFCFS(int numCores, ConsoleManager& manager)
    : numCores(numCores), running(false), paused(false), consoleManager(manager), cpuCycles(0) {

    for (int i = 0; i < numCores; ++i) {
        Worker* worker = new Worker();
        worker->coreId = i;
        workers.push_back(worker);
    }
}

SchedulerFCFS::~SchedulerFCFS() {
    stop();
    for (Worker* worker : workers) {
        delete worker;
    }
}

void SchedulerFCFS::addProcess(Process* process) {
    {
        std::lock_guard<std::mutex> lock(queuedProcessesMutex);
        if (queuedProcessesSet.find(process) == queuedProcessesSet.end()) {
            queuedProcessesSet.insert(process);
            processQueue.push(process);
        }
    }
    {
        std::lock_guard<std::mutex> lock(allProcessesMutex);
        if (std::find(allProcesses.begin(), allProcesses.end(), process) == allProcesses.end()) {
            allProcesses.push_back(process);
        }
    }
}

void SchedulerFCFS::start() {
    if (running.load()) return;
    running.store(true);
    paused.store(false);
    schedulerThread = std::thread(&SchedulerFCFS::schedulerLoop, this);
}

void SchedulerFCFS::stop() {
    if (!running.load()) return;
    running.store(false);
    paused.store(false);
    pauseCV.notify_all();
    processQueue.stop();
    if (schedulerThread.joinable()) {
        schedulerThread.join();
    }

    for (Worker* worker : workers) {
        worker->cv.notify_all();
        if (worker->thread.joinable()) {
            worker->thread.join();
        }
    }
}

void SchedulerFCFS::pause() {
    if (!running.load() || paused.load()) return;
    paused.store(true);
}

void SchedulerFCFS::resume() {
    if (!running.load() || !paused.load()) return;
    paused.store(false);
    pauseCV.notify_all();
}

bool SchedulerFCFS::isRunning() const {
    return running.load();
}

bool SchedulerFCFS::isPaused() const {
    return paused.load();
}

void SchedulerFCFS::schedulerLoop() {
    for (Worker* worker : workers) {
        worker->thread = std::thread(&SchedulerFCFS::workerLoop, this, worker->coreId);
    }

    while (running.load()) {
        // Pause handling
        while (paused.load()) {
            if (!running.load()) return;
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementIdleCpuTicks();
        }
        if (!running.load()) break;

        Process* process = nullptr;
        if (processQueue.wait_and_pop(process)) {
            if (!running.load()) break;

            // Remove from queuedProcessesSet
            {
                std::lock_guard<std::mutex> lock(queuedProcessesMutex);
                queuedProcessesSet.erase(process);
            }

            if (!process->isInMemory()) {
                // Process is not in memory, cannot schedule it
                // Try to allocate memory again
                if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                    // Requeue the process
                    addProcess(process);
                    continue;
                }
            }

            // Assign process to an idle worker
            bool assigned = false;
            while (!assigned && running.load()) {
                for (Worker* worker : workers) {
                    std::unique_lock<std::mutex> lock(worker->mtx);
                    if (!worker->busy.load()) {
                        worker->currentProcess = process;
                        worker->busy.store(true);
                        worker->cv.notify_one();
                        assigned = true;
                        break;
                    }
                }
                if (!assigned) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(1));
                    cpuCycles++;
                    consoleManager.getMemoryManager().incrementIdleCpuTicks();
                }
            }
        }
    }
}

void SchedulerFCFS::workerLoop(int coreId) {
    Worker* worker = workers[coreId];
    Config& config = Config::getInstance();
    unsigned int delayPerExec = config.getDelaysPerExec();

    while (running.load()) {
        // Pause handling
        while (paused.load()) {
            if (!running.load()) return;
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementIdleCpuTicks();
        }
        if (!running.load()) break;

        std::unique_lock<std::mutex> lock(worker->mtx);

        // Wait for a process to be assigned
        worker->cv.wait(lock, [worker, this]() {
            return worker->busy.load() || !running.load();
            });

        if (!running.load()) break;

        if (!worker->busy.load() || worker->currentProcess == nullptr) {
            // Spurious wakeup or process was set to nullptr
            continue;
        }

        Process* process = worker->currentProcess;
        lock.unlock();

        // Check if process is in memory before executing
        if (!process->isInMemory()) {
            // Process not in memory, try to allocate
            if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                // Cannot allocate memory, requeue the process
                lock.lock();
                worker->busy.store(false);
                worker->currentProcess = nullptr;
                lock.unlock();

                addProcess(process);
                continue;
            }
        }

        Command* cmd = nullptr;
        while ((cmd = process->getNextCommand()) != nullptr && running.load()) {
            // Check memory status before each instruction
            if (!process->isInMemory()) {
                // Lost memory allocation, need to requeue
                if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                    // Put command back and requeue process
                    process->addCommand(cmd);
                    addProcess(process);
                    break;
                }
            }

            // Pause handling
            while (paused.load()) {
                if (!running.load()) return;
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                cpuCycles++;
                consoleManager.getMemoryManager().incrementIdleCpuTicks();
            }
            if (!running.load()) break;

            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementActiveCpuTicks();

            // Execute instruction
            cmd->execute(process, coreId);
            delete cmd;

            process->incrementCurrentLine();

            // Simulate delay-per-exec
            for (unsigned int i = 0; i < delayPerExec; ++i) {
                cpuCycles++;
                consoleManager.getMemoryManager().incrementActiveCpuTicks();
            }
        }

        if (!running.load()) break;

        // Only deallocate memory and mark process as completed if we finished all instructions
        if (process->getNextCommand() == nullptr) {
            process->setCompleted(true);
            process->log("Process finished execution.", coreId);
            consoleManager.getMemoryManager().deallocateMemory(process);
        }

        lock.lock();
        worker->busy.store(false);
        worker->currentProcess = nullptr;
        lock.unlock();
    }
}

int SchedulerFCFS::getTotalCores() const {
    return numCores;
}

int SchedulerFCFS::getBusyCores() const {
    int busyCores = 0;
    for (const Worker* worker : workers) {
        if (worker->busy.load()) {
            busyCores++;
        }
    }
    return busyCores;
}

std::map<Process*, int> SchedulerFCFS::getRunningProcesses() const {
    std::map<Process*, int> runningProcesses;
    for (const Worker* worker : workers) {
        if (worker->currentProcess != nullptr) {
            runningProcesses[worker->currentProcess] = worker->coreId;
        }
    }
    return runningProcesses;
}

std::vector<Process*> SchedulerFCFS::getQueuedProcesses() const {
    std::vector<Process*> queuedProcesses;
    {
        std::lock_guard<std::mutex> lock(queuedProcessesMutex);
        for (auto process : queuedProcessesSet) {
            queuedProcesses.push_back(process);
        }
    }
    return queuedProcesses;
}

std::vector<Process*> SchedulerFCFS::getFinishedProcesses() const {
    std::vector<Process*> finishedProcesses;
    std::lock_guard<std::mutex> lock(allProcessesMutex);
    auto runningProcesses = getRunningProcesses();
    for (Process* process : allProcesses) {
        if (process->isCompleted() && runningProcesses.find(process) == runningProcesses.end()) {
            finishedProcesses.push_back(process);
        }
    }
    return finishedProcesses;
}

--------------------------------------------------
File End
--------------------------------------------------


./src\SchedulerFCFS.h
File type: .h
#pragma once

#include "Scheduler.h"
#include "Process.h"
#include "ConsoleManager.h"
#include <thread>
#include <vector>
#include <map>
#include <atomic>
#include <condition_variable>
#include <unordered_set>
#include "ThreadSafeQueue.h"

class SchedulerFCFS : public Scheduler {
public:
    SchedulerFCFS(int numCores, ConsoleManager& manager);
    ~SchedulerFCFS();

    void addProcess(Process* process) override;
    void start() override;
    void stop() override;
    void pause() override;
    void resume() override;
    bool isRunning() const override;
    bool isPaused() const override;

    int getTotalCores() const override;
    int getBusyCores() const override;

    std::map<Process*, int> getRunningProcesses() const override;
    std::vector<Process*> getQueuedProcesses() const override;
    std::vector<Process*> getFinishedProcesses() const override;

private:
    void schedulerLoop();
    void workerLoop(int coreId);

    int numCores;
    std::vector<std::thread> workerThreads;
    std::thread schedulerThread;

    ThreadSafeQueue<Process*> processQueue;

    std::atomic<bool> running;
    std::atomic<bool> paused;
    std::mutex pauseMutex;
    std::condition_variable pauseCV;

    struct Worker {
        int coreId = 0;
        std::atomic<bool> busy{ false };
        Process* currentProcess = nullptr;
        std::thread thread;
        std::mutex mtx;
        std::condition_variable cv;
    };

    std::vector<Worker*> workers;

    ConsoleManager& consoleManager;

    std::vector<Process*> allProcesses;
    mutable std::mutex allProcessesMutex;

    std::unordered_set<Process*> queuedProcessesSet;
    mutable std::mutex queuedProcessesMutex;

    std::atomic<unsigned int> cpuCycles;
};

--------------------------------------------------
File End
--------------------------------------------------


./src\SchedulerRR.cpp
File type: .cpp
#include "SchedulerRR.h"
#include "Command.h"
#include "Config.h"
#include <iostream>
#include <thread>
#include <algorithm>

SchedulerRR::SchedulerRR(int numCores, unsigned int quantum, ConsoleManager& manager)
    : numCores(numCores), quantum(quantum), running(false), paused(false), consoleManager(manager), cpuCycles(0) {

    for (int i = 0; i < numCores; ++i) {
        Worker* worker = new Worker();
        worker->coreId = i;
        workers.push_back(worker);
    }
}

SchedulerRR::~SchedulerRR() {
    stop();
    for (Worker* worker : workers) {
        delete worker;
    }
}

void SchedulerRR::addProcess(Process* process) {
    {
        std::lock_guard<std::mutex> lock(queuedProcessesMutex);
        if (queuedProcessesSet.find(process) == queuedProcessesSet.end()) {
            queuedProcessesSet.insert(process);
            processQueue.push(process);
        }
    }
    {
        std::lock_guard<std::mutex> lock(allProcessesMutex);
        if (std::find(allProcesses.begin(), allProcesses.end(), process) == allProcesses.end()) {
            allProcesses.push_back(process);
        }
    }
}

void SchedulerRR::start() {
    if (running.load()) return;
    running.store(true);
    paused.store(false);
    schedulerThread = std::thread(&SchedulerRR::schedulerLoop, this);
}

void SchedulerRR::stop() {
    if (!running.load()) return;
    running.store(false);
    paused.store(false);
    pauseCV.notify_all();
    processQueue.stop();
    if (schedulerThread.joinable()) {
        schedulerThread.join();
    }

    for (Worker* worker : workers) {
        worker->cv.notify_all();
        if (worker->thread.joinable()) {
            worker->thread.join();
        }
    }
}

void SchedulerRR::pause() {
    if (!running.load() || paused.load()) return;
    paused.store(true);
}

void SchedulerRR::resume() {
    if (!running.load() || !paused.load()) return;
    paused.store(false);
    pauseCV.notify_all();
}

bool SchedulerRR::isRunning() const {
    return running.load();
}

bool SchedulerRR::isPaused() const {
    return paused.load();
}

void SchedulerRR::schedulerLoop() {
    for (Worker* worker : workers) {
        worker->thread = std::thread(&SchedulerRR::workerLoop, this, worker->coreId);
    }

    while (running.load()) {
        // Pause handling
        while (paused.load()) {
            if (!running.load()) return;
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementIdleCpuTicks();
        }
        if (!running.load()) break;

        Process* process = nullptr;
        if (processQueue.wait_and_pop(process)) {
            if (!running.load()) break;

            // Remove from queuedProcessesSet
            {
                std::lock_guard<std::mutex> lock(queuedProcessesMutex);
                queuedProcessesSet.erase(process);
            }

            if (!process->isInMemory()) {
                // Process is not in memory, cannot schedule it
                // Try to allocate memory again
                if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                    // Requeue the process
                    addProcess(process);
                    continue;
                }
            }

            // Assign process to an idle worker
            bool assigned = false;
            while (!assigned && running.load()) {
                for (Worker* worker : workers) {
                    std::unique_lock<std::mutex> lock(worker->mtx);
                    if (!worker->busy.load()) {
                        worker->currentProcess = process;
                        worker->busy.store(true);
                        worker->remainingQuantum = quantum;
                        worker->cv.notify_one();
                        assigned = true;
                        break;
                    }
                }
                if (!assigned) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(1));
                    cpuCycles++;
                    consoleManager.getMemoryManager().incrementIdleCpuTicks();
                }
            }
        }
    }
}

void SchedulerRR::workerLoop(int coreId) {
    Worker* worker = workers[coreId];
    Config& config = Config::getInstance();
    unsigned int delayPerExec = config.getDelaysPerExec();

    while (running.load()) {
        // Pause handling
        while (paused.load()) {
            if (!running.load()) return;
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementIdleCpuTicks();
        }
        if (!running.load()) break;

        std::unique_lock<std::mutex> lock(worker->mtx);

        // Wait for a process to be assigned
        worker->cv.wait(lock, [worker, this]() {
            return worker->busy.load() || !running.load();
            });

        if (!running.load()) break;

        if (!worker->busy.load() || worker->currentProcess == nullptr) {
            // Spurious wakeup or process was set to nullptr
            continue;
        }

        Process* process = worker->currentProcess;
        unsigned int timeSlice = worker->remainingQuantum;

        lock.unlock();

        // Check if process is in memory before starting execution
        if (!process->isInMemory()) {
            if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                // Cannot allocate memory, requeue the process
                lock.lock();
                worker->busy.store(false);
                worker->currentProcess = nullptr;
                worker->remainingQuantum = 0;
                lock.unlock();

                process->log("Process requeued due to insufficient memory.", coreId);
                addProcess(process);
                continue;
            }
        }

        bool processCompleted = false;
        Command* lastCommand = nullptr;

        while (timeSlice > 0 && running.load()) {
            // Pause handling
            while (paused.load()) {
                if (!running.load()) return;
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                cpuCycles++;
                consoleManager.getMemoryManager().incrementIdleCpuTicks();
            }
            if (!running.load()) break;

            // Verify memory status before executing next instruction
            if (!process->isInMemory()) {
                if (!consoleManager.getMemoryManager().allocateMemory(process, process->getMemorySize())) {
                    // Lost memory allocation during execution, need to requeue
                    process->log("Process lost memory allocation, requeueing.", coreId);
                    if (lastCommand != nullptr) {
                        // Re-add the last command that couldn't be executed
                        process->addCommand(lastCommand);
                    }
                    addProcess(process);
                    break;
                }
            }

            Command* cmd = process->getNextCommand();
            lastCommand = cmd;

            if (cmd == nullptr) {
                // Process is done; deallocate memory
                process->setCompleted(true);
                process->log("Process finished execution.", coreId);
                consoleManager.getMemoryManager().deallocateMemory(process);
                processCompleted = true;
                break;
            }

            // Execute the command
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            cpuCycles++;
            consoleManager.getMemoryManager().incrementActiveCpuTicks();

            cmd->execute(process, coreId);
            delete cmd;
            lastCommand = nullptr;

            process->incrementCurrentLine();

            // Simulate delay-per-exec
            for (unsigned int i = 0; i < delayPerExec; ++i) {
                cpuCycles++;
                consoleManager.getMemoryManager().incrementActiveCpuTicks();
            }

            // Update time slice
            timeSlice--;
            worker->remainingQuantum--;
        }

        if (!running.load()) break;

        lock.lock();
        worker->busy.store(false);
        worker->currentProcess = nullptr;
        worker->remainingQuantum = 0;
        lock.unlock();

        if (!processCompleted && !process->isCompleted()) {
            // Process still has work to do, requeue it
            process->log("Process quantum expired, requeueing.", coreId);
            addProcess(process);
        }
    }
}

int SchedulerRR::getTotalCores() const {
    return numCores;
}

int SchedulerRR::getBusyCores() const {
    int busyCores = 0;
    for (const Worker* worker : workers) {
        if (worker->busy.load()) {
            busyCores++;
        }
    }
    return busyCores;
}

std::map<Process*, int> SchedulerRR::getRunningProcesses() const {
    std::map<Process*, int> runningProcesses;
    for (const Worker* worker : workers) {
        if (worker->currentProcess != nullptr) {
            runningProcesses[worker->currentProcess] = worker->coreId;
        }
    }
    return runningProcesses;
}

std::vector<Process*> SchedulerRR::getQueuedProcesses() const {
    std::vector<Process*> queuedProcesses;
    {
        std::lock_guard<std::mutex> lock(queuedProcessesMutex);
        for (auto process : queuedProcessesSet) {
            queuedProcesses.push_back(process);
        }
    }
    return queuedProcesses;
}

std::vector<Process*> SchedulerRR::getFinishedProcesses() const {
    std::vector<Process*> finishedProcesses;
    std::lock_guard<std::mutex> lock(allProcessesMutex);
    auto runningProcesses = getRunningProcesses();
    for (Process* process : allProcesses) {
        if (process->isCompleted() && runningProcesses.find(process) == runningProcesses.end()) {
            finishedProcesses.push_back(process);
        }
    }
    return finishedProcesses;
}

--------------------------------------------------
File End
--------------------------------------------------


./src\SchedulerRR.h
File type: .h
#pragma once

#include "Scheduler.h"
#include "Process.h"
#include "ConsoleManager.h"
#include <thread>
#include <vector>
#include <map>
#include <atomic>
#include <condition_variable>
#include <unordered_set>
#include "ThreadSafeQueue.h"

class SchedulerRR : public Scheduler {
public:
    SchedulerRR(int numCores, unsigned int quantum, ConsoleManager& manager);
    ~SchedulerRR();

    void addProcess(Process* process) override;
    void start() override;
    void stop() override;
    void pause() override;
    void resume() override;
    bool isRunning() const override;
    bool isPaused() const override;

    int getTotalCores() const override;
    int getBusyCores() const override;

    std::map<Process*, int> getRunningProcesses() const override;
    std::vector<Process*> getQueuedProcesses() const override;
    std::vector<Process*> getFinishedProcesses() const override;

private:
    void schedulerLoop();
    void workerLoop(int coreId);

    int numCores;
    unsigned int quantum;

    std::vector<std::thread> workerThreads;
    std::thread schedulerThread;

    ThreadSafeQueue<Process*> processQueue;

    std::atomic<bool> running;
    std::atomic<bool> paused;
    std::mutex pauseMutex;
    std::condition_variable pauseCV;

    struct Worker {
        int coreId = 0;
        std::atomic<bool> busy{ false };
        Process* currentProcess = nullptr;
        unsigned int remainingQuantum = 0;
        std::thread thread;
        std::mutex mtx;
        std::condition_variable cv;
    };

    std::vector<Worker*> workers;

    ConsoleManager& consoleManager;

    std::vector<Process*> allProcesses;
    mutable std::mutex allProcessesMutex;

    std::atomic<unsigned int> cpuCycles;

    std::unordered_set<Process*> queuedProcessesSet;
    mutable std::mutex queuedProcessesMutex;
};

--------------------------------------------------
File End
--------------------------------------------------


./src\Screen.cpp
File type: .cpp
#include "Screen.h"
#include "ConsoleManager.h"
#include "Process.h"
#include "PrintCommand.h"
#include <iostream>
#include <sstream>
#include <ctime>
#include <iomanip>

Screen::Screen(ConsoleManager& manager, Process* process)
    : consoleManager(manager), process(process) {}

void Screen::run() {
    displayProcessScreen();

    std::string input;
    while (true) {
        std::cout << process->getName() << "> ";
        std::getline(std::cin, input);

        if (input == "exit") {
            break;
        }
        else if (input == "clear") {
            system("CLS");
        }
        else {
            std::istringstream iss(input);
            std::string command;
            iss >> command;
            if (command == "print") {
                std::string message;
                std::getline(iss, message);

                if (!message.empty() && message[0] == ' ') {
                    message.erase(0, 1);
                }

                process->addCommand(new PrintCommand(message));
                std::cout << "Print command added to process.\n";

                // Reset completed status and reschedule if a command is added when process is already finished
                if (process->isCompleted()) {
                    process->resetCompleted();
                    consoleManager.getScheduler()->addProcess(process);
                }
            }
            else if (command == "process-smi") {
                displayProcessScreen();
            }
            else {
                std::cout << "Unknown command: " << command << std::endl;
            }
        }
    }
}

void Screen::displayProcessScreen() {
    std::string processName = process->getName();
    int processId = process->getId();
    std::time_t creationTime = process->getCreationTime();
    int currentLine = process->getCurrentLine();
    int totalLines = process->getTotalLines();

    double progress = 0.0;
    if (totalLines > 0) {
        progress = ((double)currentLine / totalLines) * 100.0;
        if (progress > 100.0) progress = 100.0;
    }

    std::string status;
    if (process->isCompleted()) {
        status = "Completed";
    }
    else {
        Scheduler* scheduler = consoleManager.getScheduler();
        bool isRunning = false;
        if (scheduler) {
            auto runningProcesses = scheduler->getRunningProcesses();
            if (runningProcesses.find(process) != runningProcesses.end()) {
                isRunning = true;
            }
        }

        if (isRunning) {
            status = "Executing";
        }
        else if (currentLine == 0) {
            status = "Not started";
        }
        else {
            status = "Paused";
        }
    }

    char buffer[26];
    ctime_s(buffer, sizeof(buffer), &creationTime);
    std::string creationTimeStr = buffer;
    if (!creationTimeStr.empty() && creationTimeStr.back() == '\n') {
        creationTimeStr.pop_back();
    }

    // Display process information
    std::cout << "Process: " << processName << "\n";
    std::cout << "ID: " << processId << "\n";
    std::cout << "Creation Time: " << creationTimeStr << "\n\n";

    if (process->isCompleted()) {
        // Output format for completed process
        std::cout << "Progress: " << std::fixed << std::setprecision(2) << progress << "% "
            << "(" << currentLine << " / " << totalLines << ")\n";
        std::cout << "Status: " << status << "\n\n";
    }
    else {
        // Output format for ongoing process
        std::cout << "Current instruction line: " << currentLine + 1 << "\n";
        std::cout << "Lines of code: " << totalLines << "\n";
        std::cout << "Progress: " << std::fixed << std::setprecision(2) << progress << "%\n";
        std::cout << "Status: " << status << "\n\n";
    }
}


--------------------------------------------------
File End
--------------------------------------------------


./src\Screen.h
File type: .h
#pragma once

#include "Console.h"

class ConsoleManager;
class Process;

class Screen : public Console {
public:
    Screen(ConsoleManager& manager, Process* process);
    void run() override;

private:
    void displayProcessScreen();

    ConsoleManager& consoleManager;
    Process* process;
};


--------------------------------------------------
File End
--------------------------------------------------


./src\ThreadSafeQueue.h
File type: .h
#pragma once
#include <queue>
#include <mutex>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
public:
    ThreadSafeQueue() : stopped(false) {}

    void push(T item) {
        std::lock_guard<std::mutex> lock(mtx);
        queue.push(std::move(item));
        cv.notify_one();
    }

    bool wait_and_pop(T& item) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this]() { return !queue.empty() || stopped; });
        if (stopped && queue.empty()) {
            return false;
        }
        item = std::move(queue.front());
        queue.pop();
        return true;
    }

    bool try_pop(T& item) {
        std::lock_guard<std::mutex> lock(mtx);
        if (queue.empty()) {
            return false;
        }
        item = std::move(queue.front());
        queue.pop();
        return true;
    }

    void stop() {
        std::lock_guard<std::mutex> lock(mtx);
        stopped = true;
        cv.notify_all();
    }

private:
    mutable std::mutex mtx;
    std::queue<T> queue;
    std::condition_variable cv;
    bool stopped;
};

--------------------------------------------------
File End
--------------------------------------------------
